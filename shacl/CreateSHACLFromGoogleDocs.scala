import java.io.File
import java.time.ZonedDateTime
import java.util.Calendar

import com.typesafe.scalalogging.LazyLogging
import com.github.tototoshi.csv.CSVReader

/**
 * CreateSHACLFromGoogleDocs reads the Google Docs as exported to CSV sheets in an input directory
 * and produces SHACL shapes for the specified attributes.
 */

object CreateSHACLFromGoogleDocs extends App with LazyLogging {
  val inputDir = new File(args(0))

  // Step 1. Read Type.csv to get a list of classes.
  val entities: Seq[Map[String, String]] = CSVReader.open(new File(inputDir, "Type.csv")).allWithHeaders
  val entitiesById: Map[String, Seq[Map[String, String]]] = entities.groupBy(_.getOrElse("id", "(unknown)"))

  // Step 2. Read Attribute.csv to get a list of attributes.
  val attributes: Seq[Map[String, String]] = CSVReader.open(new File(inputDir, "Attribute.csv")).allWithHeaders
  val attributesById: Map[String, Seq[Map[String, String]]] = attributes.groupBy(_.getOrElse("id", "(unknown)"))

  // Step 3. If a Type has a parentType, then it should have all the attributes of the parentType
  // as well.
  def getAllAttributes(entityId: String): Seq[Map[String, String]] = {
    if (entityId == "") return Seq()
    val attrs: Seq[Map[String, String]] = attributes.filter(attr => attr.contains("entityId") && attr("entityId") == entityId)
    val parentAttrs: Seq[Map[String, String]] = entitiesById.get(entityId).map(_.flatMap { entity: Map[String, String] =>
      entity.get("parentType").map(getAllAttributes(_)).getOrElse(Seq())
    }).getOrElse(Seq())
    parentAttrs ++ attrs
  }

  val output = System.out
  output.println(
    s"""@prefix rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#> .
       |@prefix rdfs: <http://www.w3.org/2000/01/rdf-schema#> .
       |@prefix sh: <http://www.w3.org/ns/shacl#> .
       |@prefix xsd: <http://www.w3.org/2001/XMLSchema#> .
       |@prefix obo: <http://purl.obolibrary.org/obo/> .
       |
       |@prefix BFO: <http://purl.obolibrary.org/obo/BFO_> .
       |@prefix CG: <http://dataexchange.clinicalgenome.org/CG_> .
       |@prefix DC: <http://purl.org/dc/elements/1.1/> .
       |@prefix ERO: <http://purl.obolibrary.org/obo/ERO_> .
       |@prefix FALDO: <http://biohackathon.org/resource/faldo> .
       |@prefix GENO: <http://purl.obolibrary.org/obo/GENO_> .
       |@prefix PAV: <http://purl.org/pav/> .
       |@prefix PROV: <http://www.w3.org/ns/prov#> .
       |@prefix RDFS: <http://www.w3.org/2000/01/rdf-schema#> .
       |@prefix RO: <http://purl.obolibrary.org/obo/RO_> .
       |@prefix SEPIO: <http://purl.obolibrary.org/obo/SEPIO_> .
       |@prefix SEPIO-CG: <http://purl.obolibrary.org/obo/SEPIO-CG_> .
       |
       |@prefix cgshapes: <http://dataexchange.clinicalgenome.org/interpretation/shacl/shapes/> .
       |
       |# This SHACL file was autogenerated at ${ZonedDateTime.now()}.
       |
       |""".stripMargin)

  val cardinalityRegex = """^(\d+)..(\d+|\*)$""".r

  val allAttributes = entitiesById.keys.toSeq.sorted.foreach(entityId => {
    val attributesAsString = getAllAttributes(entityId).map(attr => {
      val cardinalityStr = attr("cardinality") match {
        case cardinalityRegex(from, "*")  => s"sh:minCount $from"
        case cardinalityRegex(from, to)   => s"sh:minCount $from ;\n    sh:maxCount $to"
        case _                            => s"# Could not read cardinality '${attr("cardinality")}'"
      }

      // TODO: translate attr("dataType") into either an XSD type, class or @id.
      s"""  sh:property [
         |    sh:name "${attr("name")}" ;
         |    sh:description "${attr("description")}" ;
         |    sh:path ${attr("iri")} ; # ${attr("iri-label")}
         |    $cardinalityStr
         |  ] ;""".stripMargin
    }).mkString("\n")

    entitiesById(entityId).map(entity => {
      s"""cgshapes:${entity("name")} a sh:NodeShape ;
         |  ${if (entity.contains("iri")) s"""sh:targetClass ${entity("iri")} ; # ${entity.getOrElse("iri-label", "unlabelled")}"""}
         |  ${attributesAsString}
         |.""".stripMargin
    }).foreach(output.println(_))
  })
}
